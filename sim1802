(in-package :cl-user);;;;;;;;;;;;;;;;;;;;;  1802 processor objects;;;(define-class 1802-state r d a i n x p df ie q tr)(define-method (initialize-instance (s 1802-state) &rest args)  (declare (ignore args))  (reset s))(define-method (reset (s 1802-state r d a i n x p df ie q tr))  (declare (ignore args))  (setf   r (make-array '(16) :initial-element 0) ; 16-bit general-purpose registers   d 0  ; 8-bit accumulator   a 0  ; 16-bit address register   i 0  ; 4-bit instruction register   n 0  ; 4-bit pointer to argument register   x 0  ; 4-bit pointer to SP register   p 0  ; 4-bit pointer to PC register   df 0 ; 1-bit carry flag   ie 0 ; 1-bit interrupt enable flag   q 0  ; 1-bit user flip-flop   tr 0 ; 8-bit temporary register  ))(define-method (print-object (s 1802-state r d a i n x p df ie q tr) stream)  (format stream          "#<1802-state R=~X D=~X A=~X I=~X N=~X X=~X P=~X DF=~X IE=~X Q=~X T=~X>"          r d a i n x p df ie q tr))(define-method (get-pc (s 1802-state r p))  (aref r p));;;;;;;;;;;;;;;;;;;;;;;;;;;  Memory;;;(define-class memory start end contents protected?)(define-method (initialize-instance (mem memory start end contents protected?)                                    &key (start-address 0) (size #x10000))  (declare (ignore args))  (setf start start-address)  (setf end (+ start-address (1- size)))  (setf contents (make-array size :initial-element 0))  (setf protected? nil))(define-method (get-byte (mem memory start end contents) address)  (aref contents (- address start)))(define-method (put-byte (mem memory start end contents protected?) address byte)  (if protected?    (warn "Attempt to write to read-only memory at #x~X" address)    (setf (aref contents (- address start)) (logand byte #xFF))))(defun find-bank (mems address)  (dolist (m mems)    (if (<= (memory-start m) address (memory-end m))      (return-from find-bank m)))  (error "Attempt to access non-existent memory at #x~X" address))(define-method (get-byte (mems list) addr)  (get-byte (find-bank mems addr) addr))(define-method (put-byte (mems list) addr val)  (put-byte (find-bank mems addr) addr val))(define-method (protect (mem memory protected?) &optional (protect? t))  (setf protected? protect?))(defun load-bytes (mem bytes &optional (addr (memory-start mem)))  (dolist (byte bytes) (put-byte mem addr byte) (incf addr)))(defun dm (m addr &optional (n0 32)) ; Dump Memory  (format t "~&(dm #x~X)" addr)  (if (not (zerop (mod addr 16)))    (format t "~&~4,'0X:~VT" addr (+ 5 (* (mod addr 16) 3))))  (iterate loop ((addr addr) (n n0))    (if (zerop n)      (terpri)      (progn        (if (zerop (mod addr 16))          (format t "~&~4,'0X:" addr))        (format t " ~2,'0X" (get-byte m addr))        (loop (1+ addr) (1- n))))));;;;;;;;;;;;;;;;;;;;;;;;;  Utilities;;;(defmacro addf&mask (location addend mask)  `(setf ,location (logand (+ ,location ,addend) ,mask)))(defmacro incf-byte (location)  `(addf&mask ,location 1 #xFF))(defmacro incf-word (location)  `(addf&mask ,location 1 #xFFFF))(defmacro decf-byte (location)  `(addf&mask ,location -1 #xFF))(defmacro decf-word (location)  `(addf&mask ,location -1 #xFFFF))(defun hi-byte (n) (logand (ash n -8) #xFF))(defun lo-byte (n) (logand n #xFF))(defmacro put-hi-byte (loc byte)  `(setf ,loc (dpb (logand ,byte #xFF) (byte 8 8) ,loc)))(defmacro put-lo-byte (loc byte)  `(setf ,loc (dpb (logand ,byte #xFF) (byte 8 0) ,loc)))(defun external-flag (s n) 1) ; Ack!(define-method (execute-instruction (s 1802-state r d a i n x p df ie q tr) mem)  (macrolet ( (r (arg) `(aref r ,arg))              (mem (arg) `(get-byte mem ,arg))              (setd&df (expr)                `(let ( (v ,expr) )                   (setf d (logand v #xFF)                         df (logand (ash v -8) 1)))) )    (let* ( (instr (mem (r p))) )      (setf i (logand (ash instr -4) 15))      (setf n (logand instr 15))      (incf-word (r p))      (ecase i       (0 (cond           ( (= instr 0) (format t "~&IDLE") (decf-word (r p)) :idle )           (t (setf d (mem (r n))))))       (1 (incf-word (r n)))       (2 (decf-word (r n)))       (3 (ecase n            (0 (put-lo-byte (r p) (mem (r p))))            (1 (if (= q 1) (put-lo-byte (r p) (mem (r p))) (incf-word (r p))))            (2 (if (= d 0) (put-lo-byte (r p) (mem (r p))) (incf-word (r p))))            (3 (if (= df 1) (put-lo-byte (r p) (mem (r p))) (incf-word (r p))))            ((4 5 6 7)             (if (= (external-flag s (- n #xC)) 1)               (put-lo-byte (r p) (mem (r p)))               (incf-word (r p))))            (8 (incf-word (r p)))            (9 (if (= q 0) (put-lo-byte (r p) (mem (r p))) (incf-word (r p))))            (#xA (if (/= d 0) (put-lo-byte (r p) (mem (r p))) (incf-word (r p))))            (#xB (if (= df 0) (put-lo-byte (r p) (mem (r p))) (incf-word (r p))))            ((#xC #xD #xE #xF)             (if (= (external-flag s (- n #xC)) 0)               (put-lo-byte (r p) (mem (r p)))               (incf-word (r p))))))       (4 (setf d (mem (r n))) (incf-word (r n)))       (5 (put-byte mem (r n) d))       (6 (cond           ( (= n 0) (incf-word (r x)) )           ( (= n 68) (error "Illegal instruction: #x68") )           (t (error "I/O instruction not implemented: ~X" instr))))       (7 (ecase n            (0 (let ( (v (mem (r x))) )                 (incf-word (r x))                 (setf x (ash v -4)                       p (logand v 15)                       ie 1)))            (1 (let ( (v (mem (r x))) )                 (incf-word (r x))                 (setf x (ash v -4)                       p (logand v 15)                       ie 0)))            (2 (setf d (mem (r x))) (incf-word (r x)))            (3 (put-byte mem (r x) d) (decf-word (r x)))            (4 (setd&df (+ d (mem (r x)) df)))            (5 (setd&df (- (mem (r x)) d (if (= df 0) 1 0) #x-100)))            (6 (setf d (logior d (ash df 8))                     df (logand d 1)                     d (ash d -1)))            (7 (setd&df (- d (mem (r x)) (if (= df 0) 1 0) #x-100)))            (8 (put-byte mem (r x) tr))            (9 (let ( (v (logior (ash x 4) p)) )                 (setf tr v)                 (put-byte mem (r 2) v)                 (setf x p)                 (decf-word (r 2))))            (#xA (setf q 0))            (#xB (setf q 1))            (#xC (setd&df (+ (mem (r p)) d df)) (incf-word (r p)))            (#xD (setd&df (- (mem (r p)) d (if (= df 0) 1 0) #x-100)) (incf-word (r p)))            (#xE (setd&df (logior (ash d 1) df)))            (#xF (setd&df (- d (mem (r p)) (if (= df 0) 1 0) #x-100)) (incf-word (r p)))))       (8 (setf d (lo-byte (r n))))       (9 (setf d (hi-byte (r n))))       (#xA (put-lo-byte (r n) d))       (#xB (put-hi-byte (r n) d))       (#xC (macrolet ( (lbr-if (condition)                          `(if ,condition                            (setf (r p) (logior (ash (mem (r p)) 8) (mem (1+ (r p)))))                            (setf (r p) (+ (r p) 2))))                        (lskp-if (condition)                          `(if ,condition (setf (r p) (+ (r p) 2)))) )              (ecase n              (0 (lbr-if t))              (2 (lbr-if (= q 1)))              (3 (lbr-if (= df 1)))              (4 (lskp-if nil))              (5 (lskp-if (= q 0)))              (6 (lskp-if (/= d 0)))              (7 (lskp-if (= df 0)))              (8 (lskp-if t))              (9 (lbr-if (= q 0)))              (#xA (lbr-if (/= d 0)))              (#xB (lbr-if (= df 0)))              (#xC (lskp-if (= ie 1)))              (#xD (lskp-if (= q 1)))              (#xE (lskp-if (= d 0)))              (#xF (lskp-if (= df 1))))))       (#xD (setf p n))       (#xE (setf x n))       (#xF (ecase n             (0 (setf d (mem (r x))))             (1 (setf d (logior d (mem (r x)))))             (2 (setf d (logand d (mem (r x)))))             (3 (setf d (logxor d (mem (r x)))))             (4 (setd&df (+ d (mem (r x)))))             (5 (setd&df (- (mem (r x)) d #x-100)))             (6 (setf df (logand d 1)) (setf d (ash d -1)))             (7 (setd&df (- d (mem (r x)) #x-100)))             (8 (setf d (mem (r p))) (incf-word (r p)))             (9 (setf d (logior d (mem (r p)))) (incf-word (r p)))             (#xA (setf d (logand d (mem (r p)))) (incf-word (r p)))             (#xB (setf d (logxor d (mem (r p)))) (incf-word (r p)))             (#xC (setd&df (+ d (mem (r p)))) (incf-word (r p)))             (#xD (setd&df (- (mem (r p)) d #x-100)) (incf-word (r p)))             (#xE (setf df (logand (ash d -7) 1)) (setf d (ash d 1)))             (#xF (setd&df (- d (mem (r p)) #x-100)) (incf-word (r p)))))       ))))(define-method (interrupt (s 1802-state x p ie tr))  (when (= ie 1)    (setf tr (logior (ash x 4) p))    (setf p 1)    (setf x 2)    (setf ie 0)));;;;;;;;;;;;;;;;;;;;;;;  Systems;;;(define-class 1802-system processor memory time)(define-method (reset (s 1802-system processor time))  (reset processor)  (setf time 0))(defun make-gll-magnetometer ()  (let ( (ram (make-memory :start-address #x4000 :size #x1000))         (rom (make-memory :start-address 0 :size #x1000))         (io (make-memory :start-address #x7000 :size #x1000)) )    (load-bytes ram *gll-ram-image*)    (load-bytes rom *gll-rom-image*)    (protect rom)    (make-1802-system :processor (make-1802-state) :memory (list rom ram io) :time 0)))(define-method (forth-dump (s 1802-system processor memory time))  (format t "~&")  (let* ( (regs (1802-state-r processor))          (w (- (aref regs 9) 2))          (sp (aref regs 14))          (r (aref regs 2)) )    (format t "~&~S " time)    (dotimes (i (/ (- #x4DF0 r) 2)) (format t "-"))    (format t " ~S~30,5TS:" (car (lkup w)))    (dotimes (i (- #x4D40 sp)) (format t " ~2,'0X" (get-byte memory (+ sp i))))))(define-method (run (s 1802-system processor memory time)                       &key steps (trace nil))  (if (and (null trace) (null steps))    (loop      (dotimes (i 20000) (execute-instruction processor memory))      (print processor)      (interrupt processor))    (dotimes (i (or steps MOST-POSITIVE-FIXNUM))      (incf time)      (when (and (eq trace :forth) (= (get-pc processor) 6))        (forth-dump s))      (when (or (eq trace t)                (and (fixnump trace) (zerop (mod time trace)))                (and (compiled-function-p trace) (funcall trace s)))        (print processor)        (disasm1 memory (get-pc processor))        (format t "      (Time=~S)" time))      (when (zerop (mod time 20000))        (format t "~&*** INTERRUPT ***")        (interrupt processor))      (if (eq (execute-instruction processor memory) ':idle)        (return ':idle)))))#|(defvar *m*)(setq *m* (make-gll-magnetometer))(reset *m*)(run *m* :steps 1000 :trace :forth)(run *m* :steps 10000)(run *m* :steps 20 :trace t)(run *m* :steps 20 :trace 5)(inspect *m*)|#